# -*- coding: utf-8 -*-
"""q3_c_jazz.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1pkbv9mdBaojRxtFKcOBQ22RAvVGN6osO
"""

from google.colab import drive
drive.mount('/content/drive')

# Commented out IPython magic to ensure Python compatibility.
#%cd /content/drive/MyDrive/SMA_A1/
# %cd /content/drive/MyDrive/Semester_3/SMA/

!pip install igraph

import igraph

#the graph is read in .net format
g = igraph.read("jazz.net",format="pajek")

#We have calculated the edgelist here
edges = g.get_edgelist()

!pip install networkx
import networkx as nx

G = nx.Graph(edges) 
print(G)

# Commented out IPython magic to ensure Python compatibility.
import matplotlib.pyplot as plt

# %matplotlib inline

# visualize the graph
nx.draw(G, with_labels = True)

import networkx as nx
nx.__version__

#karate = nx.read_gml("/content/drive/MyDrive/Semester_3/SMA/karate.gml")
print(nx.info(G))
#print(G)

# start of spectral clustering
W = nx.adjacency_matrix(G)
print(W.todense())

import numpy as np

# degree matrix
D = np.diag(np.sum(np.array(W.todense()), axis=1))
print('degree matrix:')
print(D)

# laplacian matrix is generated here
L = D - W
print('laplacian matrix:')
print(L)

e, v = np.linalg.eig(L)
# eigenvalues are displayed here
print('eigenvalues:')
print(e)
# eigenvectors are displayed here
print('eigenvectors:')
print(v)

#eigenvalues & eigenvectors are ordered & returns the indices that would sort an array
v = v[:,np.argsort(e)]
e = e[np.argsort(e)]

clusters = v[:,1] > 0

#the number of clusters are returned
print(len(clusters))

new_list = np.array(clusters)
l1= new_list.tolist()
print(l1)

c0 = []
c1 = []

#the cluster belonging relation existence of each nodes are shown
for index, node in enumerate(l1):
  ele = node[0]
  print(index, ele)

#the two separate clusters are grouped accordingly
for index, node in enumerate(l1):
  if node[0]:
    c0.append(index)
  else:
    c1.append(index)

print(c0)

print(c1)